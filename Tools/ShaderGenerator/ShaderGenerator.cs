using System.Diagnostics;

namespace ET.Shader;

public static class ShaderGenerator
{
    public static void Main(string[] args)
    {
        string[] paths = FindShader($"{PathHelper.WorkSpace}\\Shaders");
        BuildShader(paths);
        GenerateVertex(paths);
        GenerateUniform(paths);
        Console.WriteLine("Build Shader Finished!");
    }

    private static string[] FindShader(string target)
    {
        var list = new List<string>();

        if (Directory.Exists(target))
        {
            list.AddRange(Directory.GetFiles(target, "*.vert"));
            list.AddRange(Directory.GetFiles(target, "*.frag"));
        }

        foreach (string name in list)
        {
            Console.WriteLine($"处理Shader: {name}");
        }
        
        return list.ToArray();
    }

    /// <summary>
    /// 编译所有Shader
    /// </summary>
    /// glslc path -o target
    private static void BuildShader(string[] paths, string target = $"{PathHelper.MainBin}\\Shaders")
    {
        foreach (string shaderPath in paths)
        {
            string fileName = Path.GetFileNameWithoutExtension(shaderPath);
            string extension = Path.GetExtension(shaderPath);
            string outputPath = Path.Combine(target, $"{fileName}{extension}.spv");
            
            // glslc 'path' -o 'target'
            using var process = new Process();
            process.StartInfo = new ProcessStartInfo
            {
                FileName = "glslc",
                Arguments = $"\"{shaderPath}\" -o \"{outputPath}\"",
                UseShellExecute = false,
                RedirectStandardOutput = true,
                RedirectStandardError = true
            };
            process.Start();
            process.WaitForExit();
        }
    }
    
    /// <summary>
    /// 检查所有vert, 找到所有layout(location = X) in XXX, 按照location顺序生成{ShaderName}Vertex到PathHelper.Vertex
    /// </summary>
    private static void GenerateVertex(string[] paths)
    {
        string[] verts = paths.Where(p => Path.GetExtension(p).ToLower() == ".vert").ToArray();
        if (verts.Length == 0)
        {
            Console.WriteLine("未找到顶点着色器文件");
            return;
        }

        var generatedCode = new List<string>();
        generatedCode.Add("//------------------------------------------------------------------------------");
        generatedCode.Add("// <auto-generated>");
        generatedCode.Add("//     This code was generated by a tool.");
        generatedCode.Add("//     Changes to this file may cause incorrect behavior and will be lost if");
        generatedCode.Add("//     the code is regenerated.");
        generatedCode.Add("// </auto-generated>");
        generatedCode.Add("//------------------------------------------------------------------------------");
        
        generatedCode.Add("using System.Numerics;");
        generatedCode.Add("using Veldrid;");
        generatedCode.Add("");
        generatedCode.Add("namespace ET.Client;");
        generatedCode.Add("");

        foreach (string vert in verts)
        {
            string shaderName = Path.GetFileNameWithoutExtension(vert);
            string shaderContent = File.ReadAllText(vert);
                
            // 解析layout(location = X) in XXX
            List<(int, string, string)> inputs = FindInput(shaderContent);
            if (inputs.Count == 0) continue;

            // 生成结构体代码
            List<string> structCode = GenerateStruct(shaderName, inputs);
            generatedCode.AddRange(structCode);
            generatedCode.Add("");
        }

        // 写入文件
        File.WriteAllLines(PathHelper.Vertex, generatedCode);
        /*Console.WriteLine();
        foreach (string s in generatedCode)
        {
            Console.WriteLine(s);
        }*/
        
        static List<(int, string, string)> FindInput(string shaderContent)
        {
            var inputs = new List<(int, string, string)>();
        
            // 匹配 layout(location = X) in XXX YYY 模式
            var pattern = @"layout\s*\(\s*location\s*=\s*(\d+)\s*\)\s*in\s+(\w+)\s+(\w+)";
            var matches = System.Text.RegularExpressions.Regex.Matches(shaderContent, pattern);
        
            foreach (System.Text.RegularExpressions.Match match in matches)
            {
                int location = int.Parse(match.Groups[1].Value);
                string type = match.Groups[2].Value;
                string name = match.Groups[3].Value;
            
                inputs.Add((location, type, name));
            }
        
            // 按location排序
            return inputs.OrderBy(x => x.Item1).ToList();
        }

        static List<string> GenerateStruct(string shaderName, List<(int, string, string)> inputs)
        {
            var code = new List<string>();
            
            code.Add($"public partial struct {shaderName}Vertex");
            code.Add("{");
            foreach ((_, string type, string name) in inputs)
            {
                code.Add($"    public {MapCSharpType(type)} {name};");
            }
            code.Add("");
            code.Add("    public static VertexLayoutDescription GetLayout()");
            code.Add("    {");
            code.Add("        return new VertexLayoutDescription(");
            for (int i = 0; i < inputs.Count; i++)
            {
                string type = inputs[i].Item2;
                string name = inputs[i].Item3;
                string format = MapFormat(type);
                string separator = i < inputs.Count - 1 ? "," : "";
                code.Add($"            new VertexElementDescription(\"{name}\", VertexElementSemantic.TextureCoordinate, VertexElementFormat.{format}){separator}");
            }
            code.Add("        );");
            code.Add("    }");
            code.Add("}");

            return code;
        }

        static string MapCSharpType(string type)
        {
            switch (type)
            {
                case "vec2": return "Vector2";
                case "vec3": return "Vector3";
                case "vec4": return "Vector4";
                default: return type;
            }
        }

        static string MapFormat(string type)
        {
            switch (type)
            {
                case "vec2": return "Float2";
                case "vec3": return "Float3";
                case "vec4": return "Float4";
                default: return type;
            }
        }
    }

    /// <summary>
    /// 检查所有vert/frag, 找到所有 layout (set = X, binding = X) uniform XXX, 生成{ShaderName}_{UniformName}Uniform到PathHelper.Uniform
    /// </summary>
    private static void GenerateUniform(string[] paths)
    {
        string[] shaders = paths.Where(p => Path.GetExtension(p).ToLower() == ".vert" || Path.GetExtension(p).ToLower() == ".frag").ToArray();
        if (shaders.Length == 0)
        {
            Console.WriteLine("未找到着色器文件");
            return;
        }

        var generatedCode = new List<string>();
        generatedCode.Add("//------------------------------------------------------------------------------");
        generatedCode.Add("// <auto-generated>");
        generatedCode.Add("//     This code was generated by a tool.");
        generatedCode.Add("//     Changes to this file may cause incorrect behavior and will be lost if");
        generatedCode.Add("//     the code is regenerated.");
        generatedCode.Add("// </auto-generated>");
        generatedCode.Add("//------------------------------------------------------------------------------");
        
        generatedCode.Add("using System.Numerics;");
        generatedCode.Add("using System.Runtime.InteropServices;");
        generatedCode.Add("");
        generatedCode.Add("namespace ET.Client;");
        generatedCode.Add("");

        foreach (string shader in shaders)
        {
            string shaderName = Path.GetFileNameWithoutExtension(shader);
            string shaderContent = File.ReadAllText(shader);
            
            // 解析layout (set = X, binding = X) uniform XXX
            Dictionary<string, (string, string)[]> uniforms = FindUniform(shaderContent);
            if (uniforms.Count == 0) continue;

            // 生成结构体代码
            List<string> structCode = GenerateStruct(shaderName, uniforms);
            generatedCode.AddRange(structCode);
            generatedCode.Add("");
        }

        // 写入文件
        File.WriteAllLines(PathHelper.Uniform, generatedCode);
        /*Console.WriteLine();
        foreach (string s in generatedCode)
        {
            Console.WriteLine(s);
        }*/
        
        static Dictionary<string, (string, string)[]> FindUniform(string shaderContent)
        {
            var uniforms = new Dictionary<string, (string, string)[]>();
            
            // 解析layout(set = X, binding = X) uniform XXX
            var pattern = @"layout\s*\(\s*set\s*=\s*(\d+)\s*,\s*binding\s*=\s*(\d+)\s*\)\s*uniform\s+(\w+)\s*\{([^}]+)\}";
            var matches = System.Text.RegularExpressions.Regex.Matches(shaderContent, pattern);
            
            foreach (System.Text.RegularExpressions.Match match in matches)
            {
                string uniformName = match.Groups[3].Value;
                string membersContent = match.Groups[4].Value;
                
                // 解析uniform成员
                var members = FindMembers(membersContent);
                
                uniforms.Add(uniformName, members);
            }
            
            return uniforms;
        }

        static (string type, string name)[] FindMembers(string membersContent)
        {
            var members = new List<(string type, string name)>();
            
            // 匹配成员声明，如 "mat4 model;" 或 "vec3 direction;"
            var pattern = @"(\w+)\s+(\w+)\s*;";
            var matches = System.Text.RegularExpressions.Regex.Matches(membersContent, pattern);
            
            foreach (System.Text.RegularExpressions.Match match in matches)
            {
                string type = match.Groups[1].Value;
                string name = match.Groups[2].Value;
                
                members.Add((type, name));
            }
            
            return members.ToArray();
        }

        static List<string> GenerateStruct(string shaderName, Dictionary<string, (string, string)[]> uniforms)
        {
            var code = new List<string>();
            
            foreach ((string uniformName, var members) in uniforms)
            {
                code.Add($"[StructLayout(LayoutKind.Sequential)]");
                code.Add($"public partial struct {shaderName}_{uniformName}Uniform");
                code.Add("{");
                
                foreach ((string type, string name) in members)
                {
                    string csharpType = MapCSharpType(type);
                    code.Add($"    public {csharpType} {name};");
                }
                
                code.Add("}");
                code.Add("");
            }
            
            return code;
        }

        static string MapCSharpType(string type)
        {
            switch (type)
            {
                case "mat4": return "Matrix4x4";
                case "mat3": return "Matrix3x3";
                case "vec2": return "Vector2";
                case "vec3": return "Vector3";
                case "vec4": return "Vector4";
                case "float": return "float";
                case "int": return "int";
                default: return type;
            }
        }
    }
}